<br/>
<hr/>
<a name="cint"></a> 
<h3>CINT</h3>
<ul>
  <li>Fix many reports from Coverity.</li>
  <li>Implement new selection #pragma for nested classes. <tt>#pragma link C++ nestedclasses</tt> is needed for CINT to <em>not ignore</em> <tt>#pragma link C++ class A::B</tt>.
  Unlike <tt>#pragma link C++ nestedtypedefs</tt> it does not by itself request dictionaries for nested classes!
  To not break old dictionaries, the latter is now implemented with the following syntax:
  <tt>#pragma link C++ class A::*</tt> will select all classes defined in <tt>A</tt>; CINT does not complain if no nested class is found.
  The selection pragma supports ROOT's flags (trailing '+' etc).
  This feature is now used by the automatic dictionary generator of ROOT, to not only request <tt>vector&lt;T&gt;</tt> but also vector&lt;T&gt;::iterator etc.</li>
  <li>Try in even more cases to automatically generate a dictionary for templates.</li>
  <li>Change the dictionary code generated for static const class data members
  of integral type so that we access these data members only by value and
  never attempt to take their address.

  <p>This allows us to work around bugs in the implementation of these kinds of
  data members in the Microsoft Visual C++ compilers (especially when dlls are
  involved it is difficult to get only one definition of the data member to be
  generated).</p>

  <p>Because of these bugs a common pattern for windows programmers is to put
  the initialization in the header file and leave out the definition in
  the implementation file, which prevents the dictionary from taking the
  address of the data member (since it has none), so we change to use only
  the value, not the address.</p>

  <p>Unfortunately the C++ standard explicitly allows these kind of data members
  to have no definition if they are not used in the program, see section 9.4.2
  paragraph 4 of ISO/IEC 14882:1998(E).</p>

  <p>In the case where a data member of this kind is <em>not</em> initialized
  in the header file and there is no definition in the source file, a link
  time error will be generated by the dictionary file.</p>

  <p>Note that this is caused by the programmer forgetting to define the
  data member, but the error is usually hidden until code attempts to use
  it, which the dictionary must do.</p></li>

  <li>Add support for building with Microsoft Visual Studio 2010, including dictionaries for its new STL.</li>

  <li>Implement new prompt interface <tt>.preproc</tt> to toggle the external preprocessing of scripts. This does not work for any file #including e.g. TObject, as it disables ROOT's ignore-include mechanism for include files (see TROOT::IgnoreInclude()).</li>

  <li>Teach CINT's preprocessor to handle <tt>#TOKEN</tt> (i.e. string conversion of CPP tokens).</li>

  <li>Fix parsing of spacing (<tt>long long</tt> stays <tt>long long</tt>, no more <tt>Unknown type TH1Ghist</tt> instead of <tt>Unknown type TH1G</tt>.)</li>

  <li>Allow creation of dictionaries for auto_ptr.</li>
  
  <li>Mark explicitly that a member was brought into the class list of member via a using statement (Property <tt>G__BIT_ISUSINGVARIABLE</tt>).  Use this information to avoid adding it to the <i>Shadow</i> classes. 

  <li><tt>G__MethodInfo</tt> now properly distinguish between the 'creator/owner' of the <tt>G__MethodInfo</tt> object and the class in which the method is declared.</li>
  
  <li>Fix the registration and lookup of typedef to any nested types.</li>
  <li>Do not 'ignore' the semi-colons inside a string (passed as a argument to a .x command).</li>
  

</ul>
